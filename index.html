<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Memory Match — SPA</title>
  <style>
    :root{
      --bg:#0f172a;         /* slate-900 */
      --panel:#111827;      /* gray-900 */
      --card:#1f2937;       /* gray-800 */
      --accent:#22d3ee;     /* cyan-400 */
      --good:#10b981;       /* emerald-500 */
      --warn:#f59e0b;       /* amber-500 */
      --text:#e5e7eb;       /* gray-200 */
      --muted:#94a3b8;      /* slate-400 */
      --shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family:system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      background: radial-gradient(1000px 600px at 10% 10%, #15213a, var(--bg));
      color:var(--text); display:flex; align-items:center; justify-content:center; padding:24px;
    }
    .app{width:min(1100px, 96vw);}
    header{display:flex; gap:16px; align-items:center; justify-content:space-between; margin-bottom:16px}
    .title{display:flex; align-items:center; gap:12px}
    .title h1{font-size:clamp(20px, 3vw, 28px); margin:0}
    .badge{font-size:12px; color:var(--muted)}

    .panel{
      background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,.0));
      border:1px solid rgba(255,255,255,.06);
      border-radius:16px; padding:16px; box-shadow:var(--shadow);
    }
    .controls{display:flex; flex-wrap:wrap; gap:12px; align-items:center; justify-content:space-between}
    .stats{display:flex; gap:16px; flex-wrap:wrap}
    .stat{background:rgba(255,255,255,.04); padding:8px 12px; border-radius:10px; border:1px solid rgba(255,255,255,.06)}
    .stat strong{color:var(--accent)}

    .btn{appearance:none; border:1px solid rgba(255,255,255,.18); background:#0b1222; color:var(--text);
      padding:10px 14px; border-radius:12px; cursor:pointer; transition:transform .06s ease, background .2s ease, border-color .2s ease}
    .btn:hover{background:#0e1730}
    .btn:active{transform:translateY(1px)}
    .btn.primary{background:linear-gradient(180deg, #0ea5b5, #0ea5b5 30%, #0b8290); border-color:#0891a3}
    .btn.primary:hover{filter:brightness(1.05)}

    .toolbar{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
    .select{background:#0b1222; color:var(--text); border:1px solid rgba(255,255,255,.18); border-radius:10px; padding:8px 10px}

    /* Board */
    .board{margin-top:16px; display:grid; gap:10px; justify-content:center}
    .card{
      width:100%; aspect-ratio:1/1; position:relative; perspective:1000px; user-select:none;
    }
    .card button{
      position:absolute; inset:0; width:100%; height:100%; border:0; padding:0; border-radius:14px; cursor:pointer;
      background:transparent; outline:none;
    }
    .face{
      position:absolute; inset:0; display:grid; place-items:center; font-size:clamp(22px, 6.5vw, 44px);
      border-radius:14px; backface-visibility:hidden; transition:transform .5s ease, background .2s ease, border-color .2s ease;
      border:1px solid rgba(255,255,255,.1);
    }
    .front{background:var(--card);}
    .back{background:linear-gradient(180deg, #12203a, #0f1b31); transform:rotateY(180deg)}

    .flipped .front{transform:rotateY(180deg)}
    .flipped .back{transform:rotateY(0)}

    .matched .front{background:linear-gradient(180deg, #063a2f, #0c4d3b); border-color:#0ea371}
    .matched .back{background:linear-gradient(180deg, #063a2f, #0c4d3b)}

    footer{margin-top:16px; display:flex; gap:10px; justify-content:space-between; align-items:center; color:var(--muted)}

    /* Focus styles */
    .card button:focus-visible{ box-shadow:0 0 0 3px rgba(34,211,238,.6); border-radius:14px }
    .btn:focus-visible{ box-shadow:0 0 0 3px rgba(34,211,238,.6) }

    /* Responsive board columns based on size selection */
    .cols-4{ grid-template-columns: repeat(4, clamp(70px, 14vw, 140px)); }
    .cols-6{ grid-template-columns: repeat(6, clamp(60px, 12vw, 120px)); }
    .cols-8{ grid-template-columns: repeat(8, clamp(48px, 9.5vw, 100px)); }

    .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0}
  </style>
</head>
<body>
  <div class="app" id="app">
    <header>
      <div class="title">
        <svg width="28" height="28" viewBox="0 0 24 24" fill="none" aria-hidden="true"><path d="M12 3l2.09 4.24L18.8 8l-3.4 3.31.8 4.69L12 13.77 7.8 16l.8-4.69L5.2 8l4.71-.76L12 3z" stroke="#22d3ee" stroke-width="1.2"/></svg>
        <h1>Memory Match</h1>
        <span class="badge">Single Page App</span>
      </div>
      <div class="toolbar">
        <label for="size" class="sr-only">Board size</label>
        <select id="size" class="select" aria-label="Board size">
          <option value="4">Easy 4×4</option>
          <option value="6">Medium 6×6</option>
          <option value="8">Hard 8×8</option>
        </select>
        <button class="btn" id="shuffleBtn" aria-label="Start a new game">New Game</button>
      </div>
    </header>

    <section class="panel">
      <div class="controls">
        <div class="stats" role="status" aria-live="polite">
          <div class="stat">Time: <strong id="time">00:00</strong></div>
          <div class="stat">Attempts: <strong id="tries">0</strong></div>
          <div class="stat">Matches: <strong id="matches">0</strong></div>
          <div class="stat" title="Best time on this device">Best: <strong id="best">—</strong></div>
        </div>
        <div class="toolbar">
          <button class="btn" id="pauseBtn" aria-pressed="false" aria-label="Pause timer">Pause</button>
          <button class="btn primary" id="restartBtn" aria-label="Restart current game">Restart</button>
        </div>
      </div>

      <div id="board" class="board cols-4" aria-label="Memory board" role="grid"></div>

      <footer>
        <small>Tip: Use <kbd>Enter</kbd> or <kbd>Space</kbd> to flip a focused card. All state is client-side.</small>
        <small><a href="#" id="repoLink" style="color:var(--accent)">View Source</a></small>
      </footer>
    </section>
  </div>

  <script>
    // ----- Simple SPA-ish boot (single view) -----
    const $ = sel => document.querySelector(sel);
    const boardEl = $('#board');
    const sizeSel = $('#size');
    const timeEl = $('#time');
    const triesEl = $('#tries');
    const matchesEl = $('#matches');
    const bestEl = $('#best');
    const pauseBtn = $('#pauseBtn');
    const restartBtn = $('#restartBtn');
    const shuffleBtn = $('#shuffleBtn');
    const repoLink = $('#repoLink');
    repoLink.href = 'https://github.com/your-username/your-repo'; // <-- set your repo link

    // Emoji set large enough for 8x8/2 = 32 unique
    const ICONS = [
      '🍎','🍌','🍇','🍉','🍒','🍑','🍍','🥝','🥑','🌶️','🥕','🌽','🍄','🥐','🍔','🍕',
      '🍟','🌭','🍿','🧁','🍪','🍩','🍫','🍰','🥨','🧇','🥞','🍗','🍤','🍣','🍙','🍜',
      '🍝','🍧','🍨','🍦','🥮','🍵','☕','🧋','🍺','🍻','🍷','🥂','🍸','🍹','🥤','🧊'
    ];

    const storeKey = 'memory-spa-v1';
    const bestKey = 'memory-best-v1';

    let state = {
      size: 4,
      deck: [], // [{id, icon, matched:false}]
      firstPick: null,
      secondPick: null,
      lock: false,
      tries: 0,
      matches: 0,
      startTs: null,
      elapsed: 0,
      timerId: null,
      paused: false,
    };

    function saveBestIfNeeded() {
      const best = JSON.parse(localStorage.getItem(bestKey) || 'null');
      if (state.matches === (state.size*state.size)/2) {
        const now = state.elapsed; // ms
        if (!best || now < best[state.size]) {
          const updated = best || {};
          updated[state.size] = now;
          localStorage.setItem(bestKey, JSON.stringify(updated));
        }
      }
      renderBest();
    }

    function renderBest(){
      const best = JSON.parse(localStorage.getItem(bestKey) || 'null');
      const val = best && best[state.size] ? formatTime(best[state.size]) : '—';
      bestEl.textContent = val;
    }

    function formatTime(ms){
      const sec = Math.floor(ms/1000);
      const m = String(Math.floor(sec/60)).padStart(2,'0');
      const s = String(sec%60).padStart(2,'0');
      return `${m}:${s}`;
    }

    function tick(){
      if (state.paused || !state.startTs) return;
      state.elapsed = Date.now() - state.startTs;
      timeEl.textContent = formatTime(state.elapsed);
    }

    function startTimer(){
      if (state.timerId) clearInterval(state.timerId);
      state.timerId = setInterval(tick, 250);
    }

    function pauseTimer(){
      state.paused = true;
      pauseBtn.setAttribute('aria-pressed','true');
      pauseBtn.textContent = 'Resume';
    }

    function resumeTimer(){
      state.paused = false;
      pauseBtn.setAttribute('aria-pressed','false');
      pauseBtn.textContent = 'Pause';
    }

    function randShuffle(arr){
      for (let i=arr.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function genDeck(size){
      const pairs = (size*size)/2;
      const chosen = ICONS.slice(0, pairs);
      const deck = chosen.flatMap((icon, idx) => ([
        { id: `${idx}-a`, icon, matched:false },
        { id: `${idx}-b`, icon, matched:false }
      ]));
      return randShuffle(deck);
    }

    function newGame(size){
      state.size = size;
      state.deck = genDeck(size);
      state.firstPick = state.secondPick = null;
      state.lock = false;
      state.tries = 0;
      state.matches = 0;
      state.startTs = null; // will set on first flip
      state.elapsed = 0;
      state.paused = false;
      timeEl.textContent = '00:00';
      triesEl.textContent = '0';
      matchesEl.textContent = '0';
      pauseBtn.textContent = 'Pause';
      pauseBtn.setAttribute('aria-pressed','false');
      renderBest();
      renderBoard();
      startTimer(); // timer runs but won't advance until first flip sets startTs
    }

    function renderBoard(){
      boardEl.classList.remove('cols-4','cols-6','cols-8');
      boardEl.classList.add(`cols-${state.size}`);
      boardEl.innerHTML = '';
      boardEl.setAttribute('aria-rowcount', state.size);
      boardEl.setAttribute('aria-colcount', state.size);

      state.deck.forEach((card, i) => {
        const cell = document.createElement('div');
        cell.className = 'card';
        cell.setAttribute('role','gridcell');
        cell.dataset.id = card.id;

        const btn = document.createElement('button');
        btn.type = 'button';
        btn.setAttribute('aria-label', 'Hidden card');
        btn.addEventListener('click', () => onFlip(card.id, btn));
        btn.addEventListener('keydown', (e)=>{
          if (e.key === 'Enter' || e.code === 'Space' || e.key === ' '){
            e.preventDefault(); onFlip(card.id, btn);
          }
        });

        const front = document.createElement('div');
        front.className = 'face front';
        front.textContent = card.matched ? '✓' : card.icon; // shows when flipped

        const back = document.createElement('div');
        back.className = 'face back';
        back.innerHTML = '<span aria-hidden="true">❓</span>';

        btn.appendChild(front);
        btn.appendChild(back);
        cell.appendChild(btn);
        boardEl.appendChild(cell);
      });
      updateFlips();
    }

    function getCard(id){
      return state.deck.find(c => c.id === id);
    }

    function onFlip(id, btn){
      if (state.paused) return;
      if (state.lock) return;
      const card = getCard(id);
      if (!card || card.matched) return;

      // Start timer on first flip
      if (!state.startTs) {
        state.startTs = Date.now();
      }

      // Prevent double-clicking the same button as second pick
      if (state.firstPick && state.firstPick.id === id) return;

      flipBtn(btn, true);

      if (!state.firstPick){
        state.firstPick = { id, icon: card.icon, el: btn.parentElement };
        return;
      }

      state.secondPick = { id, icon: card.icon, el: btn.parentElement };
      state.lock = true;
      state.tries++; triesEl.textContent = String(state.tries);

      if (state.firstPick.icon === state.secondPick.icon){
        // Match
        getCard(state.firstPick.id).matched = true;
        getCard(state.secondPick.id).matched = true;
        state.matches++; matchesEl.textContent = String(state.matches);
        state.firstPick.el.classList.add('matched');
        state.secondPick.el.classList.add('matched');
        resetPicks();

        // Win check
        if (state.matches === (state.size*state.size)/2){
          saveBestIfNeeded();
          // brief win pulse
          boardEl.animate([{filter:'brightness(1)'},{filter:'brightness(1.3)'},{filter:'brightness(1)'}],{duration:700});
        }
      } else {
        // Not a match → flip back after delay
        setTimeout(() => {
          flipBtn(state.firstPick.el.querySelector('button'), false);
          flipBtn(state.secondPick.el.querySelector('button'), false);
          resetPicks();
        }, 700);
      }
    }

    function resetPicks(){
      state.firstPick = null; state.secondPick = null; state.lock = false;
    }

    function flipBtn(buttonEl, on){
      const wrapper = buttonEl.parentElement; // .card
      wrapper.classList.toggle('flipped', on);
      // Update accessible label
      const cardId = wrapper.dataset.id;
      const card = getCard(cardId);
      if (on) {
        buttonEl.setAttribute('aria-label', `Revealed ${card.icon}`);
      } else {
        buttonEl.setAttribute('aria-label', 'Hidden card');
      }
    }

    function updateFlips(){
      // Ensure UI reflects matched cards (show as flipped)
      [...boardEl.querySelectorAll('.card')].forEach(cardEl => {
        const card = getCard(cardEl.dataset.id);
        cardEl.classList.toggle('flipped', card.matched);
        if (card.matched) cardEl.classList.add('matched');
      });
    }

    // Controls
    pauseBtn.addEventListener('click', ()=>{
      if (!state.startTs) return; // no-op until game started
      if (state.paused) { resumeTimer(); } else { pauseTimer(); }
    });

    restartBtn.addEventListener('click', ()=>{
      newGame(state.size);
    });

    shuffleBtn.addEventListener('click', ()=>{
      newGame(Number(sizeSel.value));
    });

    sizeSel.addEventListener('change', e=>{
      newGame(Number(e.target.value));
    });

    // Start
    (function init(){
      // Restore last chosen size if you want
      const last = JSON.parse(localStorage.getItem(storeKey) || 'null');
      const startSize = last?.size || 4;
      sizeSel.value = String(startSize);
      newGame(startSize);
      startTimer();
    })();

    // Persist simple prefs
    window.addEventListener('beforeunload', ()=>{
      localStorage.setItem(storeKey, JSON.stringify({ size: state.size }));
    });
  </script>
</body>
</html>
