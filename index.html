<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Memory Match - Single Page Application</title>
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --card-back: #1f2937;
      --card-front: #374151;
      --accent: #22d3ee;
      --success: #10b981;
      --text: #e5e7eb;
      --muted: #94a3b8;
      --border: rgba(255, 255, 255, 0.1);
      --shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1e293b, var(--bg));
      color: var(--text);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .app {
      max-width: 900px;
      width: 100%;
    }

    .header {
      text-align: center;
      margin-bottom: 30px;
    }

    .header h1 {
      margin: 0 0 10px 0;
      font-size: 2.5rem;
      background: linear-gradient(135deg, var(--accent), #38bdf8);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .subtitle {
      color: var(--muted);
      font-size: 0.9rem;
      margin-bottom: 20px;
    }

    .controls {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    .btn {
      padding: 10px 20px;
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 0.9rem;
    }

    .btn:hover {
      background: var(--card-back);
      border-color: var(--accent);
    }

    .btn.primary {
      background: var(--accent);
      color: var(--bg);
      font-weight: 600;
    }

    .btn.primary:hover {
      background: #06b6d4;
    }

    select {
      padding: 8px 12px;
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text);
      border-radius: 6px;
      cursor: pointer;
    }

    .game-info {
      display: flex;
      justify-content: center;
      gap: 30px;
      margin-bottom: 25px;
      flex-wrap: wrap;
    }

    .stat {
      text-align: center;
      padding: 10px 15px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 8px;
    }

    .stat-label {
      font-size: 0.8rem;
      color: var(--muted);
      margin-bottom: 5px;
    }

    .stat-value {
      font-size: 1.2rem;
      font-weight: 600;
      color: var(--accent);
    }

    .game-board {
      display: grid;
      gap: 10px;
      justify-content: center;
      margin: 30px 0;
      perspective: 1000px;
    }

    .game-board.size-4 {
      grid-template-columns: repeat(4, 90px);
    }

    .game-board.size-6 {
      grid-template-columns: repeat(6, 75px);
    }

    .game-board.size-8 {
      grid-template-columns: repeat(8, 65px);
    }

    .card {
      aspect-ratio: 1;
      position: relative;
      cursor: pointer;
      transform-style: preserve-3d;
      transition: transform 0.6s ease;
    }

    .card.flipped {
      transform: rotateY(180deg);
    }

    .card.matched {
      pointer-events: none;
    }

    .card-face {
      position: absolute;
      width: 100%;
      height: 100%;
      backface-visibility: hidden;
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
      user-select: none;
      border: 2px solid var(--border);
      transition: all 0.3s ease;
    }

    .card-back {
      background: linear-gradient(135deg, var(--card-back), #4b5563);
      color: var(--muted);
    }

    .card-front {
      background: linear-gradient(135deg, var(--card-front), #6b7280);
      transform: rotateY(180deg);
    }

    .card.matched .card-face {
      background: linear-gradient(135deg, var(--success), #059669);
      border-color: var(--success);
      box-shadow: 0 0 20px rgba(16, 185, 129, 0.3);
    }

    .card:hover:not(.flipped):not(.matched) .card-back {
      background: linear-gradient(135deg, #374151, #4b5563);
      border-color: var(--accent);
    }

    .message {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }

    .message.show {
      opacity: 1;
      pointer-events: all;
    }

    .message-content {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 40px;
      text-align: center;
      max-width: 400px;
      box-shadow: var(--shadow);
    }

    .message-content h2 {
      margin: 0 0 20px 0;
      font-size: 1.8rem;
      color: var(--accent);
    }

    .message-content p {
      margin: 10px 0;
      color: var(--muted);
    }

    .footer {
      text-align: center;
      margin-top: 30px;
      font-size: 0.8rem;
      color: var(--muted);
    }

    .footer a {
      color: var(--accent);
      text-decoration: none;
    }

    .footer a:hover {
      text-decoration: underline;
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      .header h1 {
        font-size: 2rem;
      }
      
      .game-board.size-4 {
        grid-template-columns: repeat(4, 70px);
      }
      
      .game-board.size-6 {
        grid-template-columns: repeat(6, 55px);
      }
      
      .game-board.size-8 {
        grid-template-columns: repeat(8, 45px);
      }
      
      .card-face {
        font-size: 1.5rem;
      }
    }

    /* Accessibility */
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    .card:focus {
      outline: 3px solid var(--accent);
      outline-offset: 2px;
    }
  </style>
</head>
<body>
  <div class="app">
    <header class="header">
      <h1>Memory Match</h1>
      <p class="subtitle">Single Page Application - Test your memory!</p>
      
      <div class="controls">
        <select id="difficulty" aria-label="Select difficulty level">
          <option value="4">Easy (4√ó4)</option>
          <option value="6">Medium (6√ó6)</option>
          <option value="8">Hard (8√ó8)</option>
        </select>
        <button class="btn primary" id="newGameBtn">New Game</button>
        <button class="btn" id="pauseBtn">Pause</button>
        <button class="btn" id="restartBtn">Restart</button>
      </div>
    </header>

    <main>
      <div class="game-info">
        <div class="stat">
          <div class="stat-label">Time</div>
          <div class="stat-value" id="timeDisplay">00:00</div>
        </div>
        <div class="stat">
          <div class="stat-label">Moves</div>
          <div class="stat-value" id="movesDisplay">0</div>
        </div>
        <div class="stat">
          <div class="stat-label">Matches</div>
          <div class="stat-value" id="matchesDisplay">0</div>
        </div>
        <div class="stat">
          <div class="stat-label">Best Time</div>
          <div class="stat-value" id="bestTimeDisplay">--:--</div>
        </div>
      </div>

      <div id="gameBoard" class="game-board size-4" role="grid" aria-label="Memory game board"></div>
      
      <div id="previewMessage" class="message">
        <div class="message-content">
          <h2>üß† Study the Cards!</h2>
          <p>Memorize the positions, then click any card to start the game.</p>
          <p>All other cards will flip over and the timer will begin.</p>
        </div>
      </div>

      <div id="winMessage" class="message">
        <div class="message-content">
          <h2>üéâ Congratulations!</h2>
          <p id="winDetails"></p>
          <button class="btn primary" onclick="startNewGame()">Play Again</button>
        </div>
      </div>
    </main>

    <footer class="footer">
      <p>Use <kbd>Tab</kbd> and <kbd>Enter</kbd> for keyboard navigation | All data stored locally</p>
      <p><a href="https://github.com/your-username/memory-match" target="_blank">View Source Code</a></p>
    </footer>
  </div>

  <script>
    // Game configuration and state
    const ICONS = ['üçé', 'üçå', 'üçá', 'üçâ', 'üçí', 'üçë', 'üçç', 'ü•ù', 'ü•ë', 'üå∂Ô∏è', 
                   'ü•ï', 'üåΩ', 'üçÑ', 'ü•ê', 'üçî', 'üçï', 'üçü', 'üå≠', 'üçø', 'üßÅ',
                   'üç™', 'üç©', 'üç´', 'üç∞', 'ü•®', 'üßá', 'ü•û', 'üçó', 'üç§', 'üç£',
                   'üçô', 'üçú', 'üçù', 'üçß', 'üç®', 'üç¶', 'ü•Æ', 'üçµ', '‚òï', 'üßã'];

    let gameState = {
      size: 4,
      cards: [],
      flippedCards: [],
      matchedPairs: 0,
      moves: 0,
      startTime: null,
      gameTimer: null,
      isPaused: false,
      gameStarted: false,
      showingPreview: true
    };

    // DOM elements
    const elements = {
      difficulty: document.getElementById('difficulty'),
      newGameBtn: document.getElementById('newGameBtn'),
      pauseBtn: document.getElementById('pauseBtn'),
      restartBtn: document.getElementById('restartBtn'),
      gameBoard: document.getElementById('gameBoard'),
      timeDisplay: document.getElementById('timeDisplay'),
      movesDisplay: document.getElementById('movesDisplay'),
      matchesDisplay: document.getElementById('matchesDisplay'),
      bestTimeDisplay: document.getElementById('bestTimeDisplay'),
      previewMessage: document.getElementById('previewMessage'),
      winMessage: document.getElementById('winMessage'),
      winDetails: document.getElementById('winDetails')
    };

    // Utility functions
    function shuffleArray(array) {
      const newArray = [...array];
      for (let i = newArray.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
      }
      return newArray;
    }

    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = seconds % 60;
      return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }

    function createCardElement(icon, index) {
      const card = document.createElement('div');
      card.className = 'card';
      card.setAttribute('role', 'gridcell');
      card.setAttribute('tabindex', '0');
      card.setAttribute('aria-label', `Memory card ${index + 1}`);
      card.dataset.index = index;
      card.dataset.icon = icon;

      card.innerHTML = `
        <div class="card-face card-back">‚ùì</div>
        <div class="card-face card-front">${icon}</div>
      `;

      // Add click and keyboard event listeners
      card.addEventListener('click', () => handleCardClick(card));
      card.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          handleCardClick(card);
        }
      });

      return card;
    }

    function generateCards(size) {
      const totalCards = size * size;
      const pairsNeeded = totalCards / 2;
      const selectedIcons = ICONS.slice(0, pairsNeeded);
      const cardPairs = [...selectedIcons, ...selectedIcons];
      return shuffleArray(cardPairs);
    }

    function renderGameBoard() {
      const { size } = gameState;
      elements.gameBoard.className = `game-board size-${size}`;
      elements.gameBoard.innerHTML = '';
      
      gameState.cards = generateCards(size);
      
      gameState.cards.forEach((icon, index) => {
        const cardElement = createCardElement(icon, index);
        elements.gameBoard.appendChild(cardElement);
      });

      // Show preview initially
      if (gameState.showingPreview) {
        showAllCards();
        elements.previewMessage.classList.add('show');
      }
    }

    function showAllCards() {
      const cardElements = elements.gameBoard.querySelectorAll('.card');
      cardElements.forEach(card => {
        card.classList.add('flipped');
      });
    }

    function hideAllCards() {
      const cardElements = elements.gameBoard.querySelectorAll('.card');
      cardElements.forEach(card => {
        if (!card.classList.contains('matched')) {
          card.classList.remove('flipped');
        }
      });
    }

    function handleCardClick(cardElement) {
      if (gameState.isPaused || cardElement.classList.contains('matched')) {
        return;
      }

      // First click - start the game
      if (gameState.showingPreview) {
        startGameAfterPreview(cardElement);
        return;
      }

      // Don't allow clicking during animation
      if (gameState.flippedCards.length === 2) {
        return;
      }

      // Don't allow clicking the same card twice
      if (gameState.flippedCards.includes(cardElement)) {
        return;
      }

      // Flip the card
      cardElement.classList.add('flipped');
      gameState.flippedCards.push(cardElement);

      // Check for match when two cards are flipped
      if (gameState.flippedCards.length === 2) {
        gameState.moves++;
        elements.movesDisplay.textContent = gameState.moves;
        checkForMatch();
      }
    }

    function startGameAfterPreview(clickedCard) {
      gameState.showingPreview = false;
      gameState.gameStarted = true;
      elements.previewMessage.classList.remove('show');
      
      // Hide all cards except the clicked one
      hideAllCards();
      clickedCard.classList.add('flipped');
      gameState.flippedCards = [clickedCard];
      
      // Start the timer
      gameState.startTime = Date.now();
      startTimer();
    }

    function checkForMatch() {
      const [card1, card2] = gameState.flippedCards;
      const icon1 = card1.dataset.icon;
      const icon2 = card2.dataset.icon;

      if (icon1 === icon2) {
        // Match found
        setTimeout(() => {
          card1.classList.add('matched');
          card2.classList.add('matched');
          gameState.matchedPairs++;
          elements.matchesDisplay.textContent = gameState.matchedPairs;
          gameState.flippedCards = [];
          
          // Check for win condition
          const totalPairs = (gameState.size * gameState.size) / 2;
          if (gameState.matchedPairs === totalPairs) {
            setTimeout(() => endGame(), 500);
          }
        }, 1000);
      } else {
        // No match - flip cards back
        setTimeout(() => {
          card1.classList.remove('flipped');
          card2.classList.remove('flipped');
          gameState.flippedCards = [];
        }, 1000);
      }
    }

    function startTimer() {
      gameState.gameTimer = setInterval(() => {
        if (!gameState.isPaused && gameState.gameStarted) {
          const elapsed = Math.floor((Date.now() - gameState.startTime) / 1000);
          elements.timeDisplay.textContent = formatTime(elapsed);
        }
      }, 1000);
    }

    function stopTimer() {
      if (gameState.gameTimer) {
        clearInterval(gameState.gameTimer);
        gameState.gameTimer = null;
      }
    }

    function endGame() {
      stopTimer();
      const totalTime = Math.floor((Date.now() - gameState.startTime) / 1000);
      const timeText = formatTime(totalTime);
      
      // Check for new best time
      const bestKey = `memoryMatch_best_${gameState.size}`;
      const currentBest = localStorage.getItem(bestKey);
      let isNewBest = false;
      
      if (!currentBest || totalTime < parseInt(currentBest)) {
        localStorage.setItem(bestKey, totalTime.toString());
        isNewBest = true;
        updateBestTimeDisplay();
      }
      
      // Show win message
      elements.winDetails.innerHTML = `
        <p><strong>Time:</strong> ${timeText}</p>
        <p><strong>Moves:</strong> ${gameState.moves}</p>
        ${isNewBest ? '<p style="color: #f59e0b;">üèÜ New Best Time!</p>' : ''}
      `;
      elements.winMessage.classList.add('show');
    }

    function updateBestTimeDisplay() {
      const bestKey = `memoryMatch_best_${gameState.size}`;
      const best = localStorage.getItem(bestKey);
      elements.bestTimeDisplay.textContent = best ? formatTime(parseInt(best)) : '--:--';
    }

    function resetGameState() {
      stopTimer();
      gameState = {
        ...gameState,
        cards: [],
        flippedCards: [],
        matchedPairs: 0,
        moves: 0,
        startTime: null,
        gameTimer: null,
        isPaused: false,
        gameStarted: false,
        showingPreview: true
      };
      
      // Reset displays
      elements.timeDisplay.textContent = '00:00';
      elements.movesDisplay.textContent = '0';
      elements.matchesDisplay.textContent = '0';
      elements.pauseBtn.textContent = 'Pause';
    }

    function startNewGame() {
      elements.winMessage.classList.remove('show');
      elements.previewMessage.classList.remove('show');
      resetGameState();
      gameState.size = parseInt(elements.difficulty.value);
      updateBestTimeDisplay();
      renderGameBoard();
    }

    function togglePause() {
      if (!gameState.gameStarted) return;
      
      gameState.isPaused = !gameState.isPaused;
      elements.pauseBtn.textContent = gameState.isPaused ? 'Resume' : 'Pause';
    }

    // Event listeners
    elements.newGameBtn.addEventListener('click', startNewGame);
    elements.restartBtn.addEventListener('click', startNewGame);
    elements.pauseBtn.addEventListener('click', togglePause);
    elements.difficulty.addEventListener('change', startNewGame);

    // Make startNewGame globally available for win message button
    window.startNewGame = startNewGame;

    // Initialize the game
    updateBestTimeDisplay();
    renderGameBoard();
  </script>
</body>
</html>
